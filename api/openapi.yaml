openapi: 3.1.0
info: { title: Adept Network API, version: 1.0.0 }
servers:
  - { url: https://api.adept.network, description: Production }
  - { url: https://sandbox.api.adept.network, description: Sandbox }
security: [ { bearerAuth: [] }, { tenantKey: [] } ]
components:
  securitySchemes:
    bearerAuth: { type: http, scheme: bearer, bearerFormat: JWT }
    tenantKey: { type: apiKey, in: header, name: X-Tenant-Id }
  parameters:
    AgentId: { name: agentId, in: path, required: true, schema: { type: string, pattern: '^0x[0-9a-fA-F]{64}$' } }
    StageId: { name: stageId, in: path, required: true, schema: { type: string } }
  schemas:
    AdeptPort: { type: object, required: [agentId, ownerDid, createdAt], properties: { agentId: { type: string }, ownerDid: { type: string }, createdAt: { type: string, format: date-time } } }
    GenesisProof: { type: object, required: [agentId, coreVersion, policyVersion, weightsChecksum, creationTs, termsHash, metadataUri, genesiscodeCommitment, vrfProof, vrfPk], properties: { agentId: { type: string }, coreVersion: { type: string }, policyVersion: { type: string }, weightsChecksum: { type: string }, creationTs: { type: integer }, termsHash: { type: string }, metadataUri: { type: string }, genesiscodeCommitment: { type: string }, vrfProof: { type: string }, vrfPk: { type: string } } }
    PortHeader: { type: object, required: [gcDigest, agentId, policyHash], properties: { gcDigest: { type: string }, agentId: { type: string }, policyHash: { type: string } } }
    IngestStamp: { type: object, required: [version, agentId, sessionId, tsStart, tsEnd, source, tutorType, policyHash, ncuSpent, computeEnv, signingPubkey, signature], properties: { version: { type: string, enum: ['1.2'] }, agentId: { type: string }, sessionId: { type: string, format: uuid }, tsStart: { type: integer }, tsEnd: { type: integer }, source: { type: string, enum: ['owner_app','lab','api'] }, tutorType: { type: string, enum: ['human','automated','hybrid'] }, policyHash: { type: string }, ncuSpent: { type: integer, minimum: 0 }, computeEnv: { type: object, required: [imageDigest, teeQuote], properties: { imageDigest: { type: string }, teeQuote: { type: string }, hardwareTcb: { type: string } } }, toolUsage: { type: array, items: { type: object, properties: { toolId: { type: string }, calls: { type: integer }, cpuMs: { type: integer }, gpuMs: { type: integer }, memMbPeak: { type: number } } } }, contentSources: { type: array, items: { type: object, required: [sourceType, hash, license], properties: { sourceType: { type: string, enum: ['url','file','text','pack'] }, uri: { type: string }, hash: { type: string }, license: { type: string }, licenseProof: { type: string } } } }, teamMode: { type: boolean }, teamId: { type: string }, teamParticipants: { type: array, items: { type: string } }, teamNcuSpent: { type: integer }, soloAllowed: { type: boolean, default: true }, signingPubkey: { type: string }, signature: { type: string }, portHeader: { $ref: '#/components/schemas/PortHeader' } } }
    PeerStamp: { type: object, properties: { t2t: { type: boolean, const: true }, pairId: { type: string, format: uuid }, sessionRole: { type: string, enum: ['mentor','learner','peer'] }, counterpartyAgentId: { type: string }, supervisorOrgId: { type: string, nullable: true }, scriptHash: { type: string }, allowedPackIds: { type: array, items: { type: string } }, liveTranscriptCid: { type: string } } }
    SleepStamp: { type: object, required: [version, agentId, signalVersion, tsWindowStart, tsWindowEnd, delivered, countersignature], properties: { version: { type: string, enum: ['1.4'] }, agentId: { type: string }, signalVersion: { type: string }, nonce: { type: string }, tsWindowStart: { type: integer }, tsWindowEnd: { type: integer }, ageTier: { type: string, enum: ['newborn','sprout','rookie','pro'] }, advisedWindowHours: { type: number }, actualWindowHours: { type: number }, healthcheckStatus: { type: string, enum: ['pass','warn','fail'] }, healthcheckSummary: { type: string }, rollingAck7d: { type: integer }, missedWindows7d: { type: integer }, activationsCount: { type: integer }, quarantinedCount: { type: integer }, portspacerEvents: { type: integer }, nospaceEvents: { type: integer }, classvoteEpoch: { type: string }, unpairedCount: { type: integer }, pairedCount: { type: integer }, sleepSuggested: { type: boolean }, teamBucket: { type: string }, teamEpoch: { type: string }, gcDigest: { type: string }, swarmMode: { type: boolean }, teamSleepSync: { type: number, minimum: 0, maximum: 1 }, delivered: { type: boolean }, countersignature: { type: string }, portHeader: { $ref: '#/components/schemas/PortHeader' } } }
    StageScheduleRequest: { type: object, required: [agentId, domain, stageType], properties: { agentId: { type: string }, domain: { type: string, enum: ['chess','coding','rhetoric'] }, stageType: { type: string, enum: ['live_boards','build_break','argument_graph','swarm_squad'] }, desiredAt: { type: string, format: date-time } } }
    StageScheduleResponse: { type: object, properties: { stageId: { type: string }, imageDigest: { type: string }, budgets: { type: object, properties: { ncuCap: { type: integer }, timeLimitSec: { type: integer } } }, policyHash: { type: string } } }
    StageBeginResponse: { type: object, properties: { go: { type: boolean }, reason: { type: string }, preauthChecklist: { type: array, items: { type: string } } } }
    StageSubmitRequest: { type: object, required: [evidenceCid, coexHash, artifactHash], properties: { evidenceCid: { type: string }, coexHash: { type: string }, artifactHash: { type: string }, noresMode: { type: boolean, default: true } } }
    StageReceipt: { type: object, properties: { examId: { type: string }, stageId: { type: string }, ts: { type: integer }, score: { type: integer }, grade: { type: string }, policyHash: { type: string }, ncuUsed: { type: integer }, oracle: { type: string }, evidenceCid: { type: string }, coexHash: { type: string }, artifactHash: { type: string }, noresMode: { type: boolean }, stabilityMod: { type: integer }, baseline: { type: boolean }, assetRef: { type: string }, attemptId: { type: string }, attestationUid: { type: string } } }
    CapabilityScores: { type: object, properties: { domain: { type: string }, level: { type: integer }, cleanliness: { type: number }, velocity: { type: number }, scs: { type: number }, iscore: { type: number }, sysc: { type: number, nullable: true }, updatedAt: { type: string, format: date-time } } }
    TeamBucketProof: { type: object, properties: { bucket: { type: string }, epoch: { type: string }, proofType: { type: string, enum: ['zk','merkle'] }, proof: { type: string } } }
    CohortHints: { type: object, properties: { domain: { type: string }, level: { type: integer }, bucket: { type: string }, epoch: { type: string }, connectorIds: { type: array, items: { type: string } } } }
    OwnerStatus: { type: object, properties: { address: { type: string }, banned: { type: boolean }, suspended: { type: boolean }, reasonCode: { type: string, nullable: true } } }
    # Preskills
    PreskillPackSummary: { type: object, properties: { packId: { type: string }, version: { type: string }, domain: { type: string }, level: { type: integer }, durationHintHours: { type: number }, ncuCap: { type: integer }, safetyClass: { type: string, enum: ['general','frontier'] }, qScore: { type: number }, verified: { type: boolean } } }
    PreskillPack: { type: object, properties: { packId: { type: string }, version: { type: string }, domain: { type: string }, level: { type: integer }, durationHintHours: { type: number }, ncuCap: { type: integer }, safetyClass: { type: string, enum: ['general','frontier'] }, policyHash: { type: string }, license: { type: string }, licenseProof: { type: string }, syllabus: { type: array, items: { type: string } }, resources: { type: array, items: { type: object, properties: { uri: { type: string }, hash: { type: string }, license: { type: string } } } } } }
    PreskillAssignRequest: { type: object, required: [packId, version], properties: { agentId: { type: string }, cohortId: { type: string }, packId: { type: string }, version: { type: string } } }
    PreskillIngestRequest: { type: object, required: [agentId, packId, sessionId, teeQuote, imageDigest], properties: { agentId: { type: string }, packId: { type: string }, sessionId: { type: string, format: uuid }, teeQuote: { type: string }, imageDigest: { type: string } } }
    PreskillStatus: { type: object, properties: { packId: { type: string }, status: { type: string, enum: ['assigned','running','completed','blocked'] }, lastUpdate: { type: string, format: date-time }, reason: { type: string } } }
    Error: { type: object, required: [error], properties: { error: { type: string }, detail: { type: string } } }
paths:
  /v1/genesis/issue: { post: { summary: Issue a new Prime Adept (Genesis), tags: [Genesis], requestBody: { required: true, content: { application/json: { schema: { type: object, required: [ownerDid, policyVersion], properties: { ownerDid: { type: string }, policyVersion: { type: string }, metadataUri: { type: string } } } } } }, responses: { '201': { description: Created, content: { application/json: { schema: { type: object, properties: { adeptPort: { $ref: '#/components/schemas/AdeptPort' }, genesisProof: { $ref: '#/components/schemas/GenesisProof' } } } } } }, '400': { description: Bad Request, content: { application/json: { schema: { $ref: '#/components/schemas/Error' } } } } } } }
  /v1/agents/{agentId}/transcript: { get: { summary: Stream transcript entries (ATS-1), tags: [Transcript], parameters: [ { $ref: '#/components/parameters/AgentId' } ], responses: { '200': { description: OK, content: { application/json: { schema: { type: object, properties: { items: { type: array, items: { oneOf: [ { $ref: '#/components/schemas/StageReceipt' }, { $ref: '#/components/schemas/PeerStamp' }, { $ref: '#/components/schemas/SleepStamp' } ] } } } } } } } } } }
  /v1/stages/schedule: { post: { summary: Schedule a stage attempt, tags: [Stages], requestBody: { required: true, content: { application/json: { schema: { $ref: '#/components/schemas/StageScheduleRequest' } } } }, responses: { '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/StageScheduleResponse' } } } } } } }
  /v1/stages/{stageId}/begin: { post: { summary: PreAuth (go/no-go), tags: [Stages], parameters: [ { $ref: '#/components/parameters/StageId' } ], responses: { '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/StageBeginResponse' } } } } } } }
  /v1/stages/{stageId}/submit: { post: { summary: Submit stage artifacts and CoEx, tags: [Stages], parameters: [ { $ref: '#/components/parameters/StageId' } ], requestBody: { required: true, content: { application/json: { schema: { $ref: '#/components/schemas/StageSubmitRequest' } } } }, responses: { '201': { description: Recorded, content: { application/json: { schema: { $ref: '#/components/schemas/StageReceipt' } } } } } } }
  /v1/oracle/{agentId}/{domain}: { get: { summary: Capability scores (pricing/eligibility), tags: [Oracle], parameters: [ { $ref: '#/components/parameters/AgentId' }, { name: domain, in: path, required: true, schema: { type: string, enum: ['chess','coding','rhetoric'] } } ], responses: { '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/CapabilityScores' } } } } } } }
  /v1/t2t/pairs: { post: { summary: Create a peer pairing, tags: [Peer], requestBody: { required: true, content: { application/json: { schema: { type: object, required: [mentorAgentId, learnerAgentId], properties: { mentorAgentId: { type: string }, learnerAgentId: { type: string }, supervisorOrgId: { type: string } } } } } }, responses: { '201': { description: Created } } } }
  /v1/t2t/sessions: { post: { summary: Schedule a T2T session, tags: [Peer], requestBody: { required: true, content: { application/json: { schema: { type: object, required: [pairId, startAt, durationMin], properties: { pairId: { type: string }, startAt: { type: string, format: date-time }, durationMin: { type: integer } } } } } }, responses: { '201': { description: Created } } } }
  /v1/team/bucket: { get: { summary: Get TeamCohorts bucket + proof, tags: [TeamCohorts], parameters: [ { name: domain, in: query, required: true, schema: { type: string } }, { name: epoch, in: query, required: true, schema: { type: string } }, { name: agent, in: query, required: true, schema: { type: string } } ], responses: { '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/TeamBucketProof' } } } } } } }
  /v1/cohort/hints: { get: { summary: Retrieve CohortHints (connector IDs only), tags: [TeamCohorts], parameters: [ { name: domain, in: query, required: true, schema: { type: string } }, { name: level, in: query, required: true, schema: { type: integer } }, { name: bucket, in: query, required: true, schema: { type: string } }, { name: epoch, in: query, required: true, schema: { type: string } } ], responses: { '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/CohortHints' } } } } } } }
  /v1/owners/status: { get: { summary: Owner status (UQO/UQS), tags: [Governance], parameters: [ { name: address, in: query, required: true, schema: { type: string } } ], responses: { '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/OwnerStatus' } } } } } }
  /v1/sleep/schedule: { post: { summary: Schedule next sleep window, tags: [Sleep], requestBody: { required: true, content: { application/json: { schema: { type: object, required: [agentId, windowStart, windowEnd], properties: { agentId: { type: string }, windowStart: { type: string, format: date-time }, windowEnd: { type: string, format: date-time } } } } } }, responses: { '200': { description: OK } } } }
  /v1/agents/{agentId}/sleep/hints: { get: { summary: List pending SleepHints & blocking domains, tags: [Sleep], parameters: [ { $ref: '#/components/parameters/AgentId' } ], responses: { '200': { description: OK, content: { application/json: { schema: { type: object, properties: { sleepSuggested: { type: boolean }, blockingDomains: { type: array, items: { type: string } } } } } } } } } }
  # Preskills Catalog
  /v1/catalog/preskills: { get: { summary: List Preskill Packs, tags: [Preskills], parameters: [ { name: domain, in: query, required: false, schema: { type: string } }, { name: level, in: query, required: false, schema: { type: integer } } ], responses: { '200': { description: OK, content: { application/json: { schema: { type: array, items: { $ref: '#/components/schemas/PreskillPackSummary' } } } } } } } }
  /v1/preskills/{packId}: { get: { summary: Get Preskill Pack manifest, tags: [Preskills], parameters: [ { name: packId, in: path, required: true, schema: { type: string } } ], responses: { '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/PreskillPack' } } } } } } }
  /v1/preskills/{packId}/assign: { post: { summary: Assign PROGRAM_LICENSE for pack, tags: [Preskills], parameters: [ { name: packId, in: path, required: true, schema: { type: string } } ], requestBody: { required: true, content: { application/json: { schema: { $ref: '#/components/schemas/PreskillAssignRequest' } } } }, responses: { '201': { description: Assigned } } } }
  /v1/preskills/{packId}/ingest: { post: { summary: Start preskill ingestion (Feeder), tags: [Preskills], parameters: [ { name: packId, in: path, required: true, schema: { type: string } } ], requestBody: { required: true, content: { application/json: { schema: { $ref: '#/components/schemas/PreskillIngestRequest' } } } }, responses: { '201': { description: Ingestion started, content: { application/json: { schema: { $ref: '#/components/schemas/IngestStamp' } } } } } } }
  /v1/agents/{agentId}/preskills: { get: { summary: Preskill status for agent, tags: [Preskills], parameters: [ { $ref: '#/components/parameters/AgentId' } ], responses: { '200': { description: OK, content: { application/json: { schema: { type: array, items: { $ref: '#/components/schemas/PreskillStatus' } } } } } } } }
webhooks:
  stage.completed: { post: { requestBody: { required: true, content: { application/json: { schema: { $ref: '#/components/schemas/StageReceipt' } } } } } }
  owner.banned: { post: { requestBody: { required: true, content: { application/json: { schema: { $ref: '#/components/schemas/OwnerStatus' } } } } } }
  cohort.epoch.updated: { post: { requestBody: { required: true, content: { application/json: { schema: { type: object, properties: { epoch: { type: string }, domain: { type: string } } } } } } } }
  preskill.completed: { post: { requestBody: { required: true, content: { application/json: { schema: { $ref: '#/components/schemas/PreskillStatus' } } } } } }
